# 变量定义
qos_constraint：Qos上限，只有当客户和边缘节点之间的Qos==小于==上限时，才可以提供服务
data_demand: 时间-客户（100*10） 每个时间点每个客户的需求
data_qos: 边缘节点-客户（100*10）   每个边缘节点和每个客户之间的Qos值
data_bandwidth: 边缘节点 （100*1）  每个边缘节点的带宽上限
time_total: 总时间点个数 （100）
customer_total:总客户数   （10）
node_total:总边缘节点数   （100）
th: 95分位带宽下可容许的免费时间点数  计算方式 int(time_total*0.05)     （5）
time_node: 时间-边缘节点需求矩阵（100*100）  每个时间点每个边缘节点可提供的总需求  计算方式：data_demand和data_qos转置的矩阵乘




# 第一阶段算法

## 思路：
目标：最大化利用每个边缘节点的th个免费时间点
同时考虑时间维度和边缘节点维度，
找到time_node中最大的点，即该节点在该时刻的可提供需求全局最大
然后让该边缘节点的可提供需求全部被满足，
反复遍历，
若某边缘节点的使用次数达到th次，则不再让该边缘节点分配带宽。


## 伪代码：





# 第二阶段算法思路

## 伪代码：
    for 当前时间 in  所有时间：
        
        for 节点 in 所有边缘节点
            1.计算每个边缘节点可提供的总需求，并进行排序得到记录(边缘节点索引，可提供总需求)的排序数组（过滤提供总需求为0的边缘节点）arr（降序）
            2.选取节点：
                for cur in arr:
                    如果cur对应节点被使用过（在第二阶段的当前时间点已经提供过需求），那么 cur+=1
                    否则，跳出循环，cur即为将进行分配的节点
            3.第一次分配和更新（以阈值为上限按比例分配）：
                如果cur已经超出arr范围，即所有节点都已提供过需求，或没有节点可提供需求，则跳出循环，进入下一个时间点
                否则，执行第一次分配：
                    1）如果cur节点可提供总需求超过阈值：那么将可提供需求该为阈值，作为将要进行分配的带宽；否则，可提供总需求即为将要进行分配的带宽
                    2）将带宽按比例分配给客户（比例的计算方式为：该客户需求/所有客户需求） 这里的客户应以满足Qos约束为前提
                    3）对矩阵表进行更新：data_demand、time_node、time_node_custom,并记录该节点使用过一次
            4.第二次分配和更新：
                for cur in 所有节点：
                    1）得到arr
                    2）如果arr中第一个节点的可提供需求为0，则跳出循环，否则执行下一步
                    3）分配可提供客户的所有需求
                    4）对矩阵表进行更新：data_demand、time_node、time_node_custom

