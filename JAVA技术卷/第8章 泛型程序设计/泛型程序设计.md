# 1.为什么要使用泛型程序设计？
比如ArrayList，以前可能需要使用强转，现在可以使用类型参数

# 2.简单使用
## 泛型类
```java
public class Pair<T>{
    private T first;
    private T second;
    public Pair(T first,T seond){this.first=first,this.second=second;}
}
```
类型变量放在类的后面
T为类型变量作为泛型参数其中一个，可以是任意个

## 泛型方法
```java
class ArrayAlg{
    public static<T> T getMiddle(T... a){
        return a[a.length/2];
    }
}
```
标准使用方式：
```java
String middle=ArrayAlg.<String>getMiddle("John","Q.","Public");
```

大多数情况使用方法：
```java
String middle=ArrayAlg.getMiddle("John","Q.","Public");
```


## 类型变量的限定
```java
public class ArrayAlg{
    public static<T> T min(T[] arr){
        if(arr==null||arr.length==0)  return null;
        T smallest=a[0];
        for(int i=1;i<arr.length;i++){
            if(smallest.compareTo(arr[i]>0))  smallest=arr[i];
        }
        return smallest;
    }
}
```

如何确保smallest有compareTo方法呢？ 对类型变量设置限定
```java
public  static<T extends Comparable> T min(T[] a)
```
实际上Comparable本身就是一个泛型类型，不能这么用

    如果需要多个限定怎么办？
    一个类型变量或通配符可以有多个限定。
    T extends Comparable & Serializable


## 类型擦除
[JAVA类型擦除](https://www.jianshu.com/p/bbceddd578e5)
泛型信息只存在编译阶段，在进入JVM之前，与泛型相关的信息会被擦掉（类型擦除）。
List<String>和List<Integer>在JVM中的Class都是List.class

有限定类型就被替换成类型上限的第一个，没有就被替换成Objcet
### 在Class文件中是怎样的？
用上面的pair类进行测试，泛型和非泛型的区别



Classfile /D:/untitled/Pair.class
  Last modified 2022-9-26; size 417 bytes
  MD5 checksum 5c9797f392284152efea55196ae70ff0
  Compiled from "Main.java"
class Pair<T extends java.lang.Object> extends java.lang.Object
  minor version: 0
  major version: 52
  flags: ACC_SUPER
Constant pool:
   #1 = Methodref          #5.#19         // java/lang/Object."<init>":()V
   #2 = Fieldref           #4.#20         // Pair.first:Ljava/lang/Object;
   #3 = Fieldref           #4.#21         // Pair.second:Ljava/lang/Object;
   #4 = Class              #22            // Pair
   #5 = Class              #23            // java/lang/Object
   #6 = Utf8               first
   #7 = Utf8               Ljava/lang/Object;
   #8 = Utf8               Signature
   #9 = Utf8               TT;
  #10 = Utf8               second
  #11 = Utf8               <init>
  #12 = Utf8               (Ljava/lang/Object;Ljava/lang/Object;)V
  #13 = Utf8               Code
  #14 = Utf8               LineNumberTable
  #15 = Utf8               (TT;TT;)V
  #16 = Utf8               <T:Ljava/lang/Object;>Ljava/lang/Object;
  #17 = Utf8               SourceFile
  #18 = Utf8               Main.java
  #19 = NameAndType        #11:#24        // "<init>":()V
  #20 = NameAndType        #6:#7          // first:Ljava/lang/Object;
  #21 = NameAndType        #10:#7         // second:Ljava/lang/Object;
  #22 = Utf8               Pair
  #23 = Utf8               java/lang/Object
  #24 = Utf8               ()V
{
  public T first;
    descriptor: Ljava/lang/Object;
    flags: ACC_PUBLIC
    Signature: #9                           // TT;

  public T second;
    descriptor: Ljava/lang/Object;
    flags: ACC_PUBLIC
    Signature: #9                           // TT;

  public Pair(T, T);
    descriptor: (Ljava/lang/Object;Ljava/lang/Object;)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=3
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: aload_1
         6: putfield      #2                  // Field first:Ljava/lang/Object;
         9: aload_0
        10: aload_2
        11: putfield      #3                  // Field second:Ljava/lang/Object;
        14: return
      LineNumberTable:
        line 15: 0
        line 16: 9
    Signature: #15                          // (TT;TT;)V
}
Signature: #16                          // <T:Ljava/lang/Object;>Ljava/lang/Object;
SourceFile: "Main.java"




Classfile /D:/untitled/Pair.class
  Last modified 2022-9-26; size 312 bytes
  MD5 checksum bcf9742178ef817cf60d48ca70e732b3
  Compiled from "Main.java"
class Pair
  minor version: 0
  major version: 52
  flags: ACC_SUPER
Constant pool:
   #1 = Methodref          #5.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #4.#16         // Pair.first:Ljava/lang/Object;
   #3 = Fieldref           #4.#17         // Pair.second:Ljava/lang/Object;
   #4 = Class              #18            // Pair
   #5 = Class              #19            // java/lang/Object
   #6 = Utf8               first
   #7 = Utf8               Ljava/lang/Object;
   #8 = Utf8               second
   #9 = Utf8               <init>
  #10 = Utf8               (Ljava/lang/Object;Ljava/lang/Object;)V
  #11 = Utf8               Code
  #12 = Utf8               LineNumberTable
  #13 = Utf8               SourceFile
  #14 = Utf8               Main.java
  #15 = NameAndType        #9:#20         // "<init>":()V
  #16 = NameAndType        #6:#7          // first:Ljava/lang/Object;
  #17 = NameAndType        #8:#7          // second:Ljava/lang/Object;
  #18 = Utf8               Pair
  #19 = Utf8               java/lang/Object
  #20 = Utf8               ()V
{
  public java.lang.Object first;
    descriptor: Ljava/lang/Object;
    flags: ACC_PUBLIC

  public java.lang.Object second;
    descriptor: Ljava/lang/Object;
    flags: ACC_PUBLIC

  public Pair(java.lang.Object, java.lang.Object);
    descriptor: (Ljava/lang/Object;Ljava/lang/Object;)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=3
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: aload_1
         6: putfield      #2                  // Field first:Ljava/lang/Object;
         9: aload_0
        10: aload_2
        11: putfield      #3                  // Field second:Ljava/lang/Object;
        14: return
      LineNumberTable:
        line 15: 0
        line 16: 9
}


Classfile /D:/untitled/Main.class
  Last modified 2022-9-26; size 554 bytes
  MD5 checksum 639533877d159cb1b5112bc619189551
  Compiled from "Main.java"
public class Main
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #11.#20        // java/lang/Object."<init>":()V
   #2 = Class              #21            // Pair
   #3 = String             #22            // a
   #4 = String             #23            // b
   #5 = Methodref          #2.#24         // Pair."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
   #6 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;
   #7 = Fieldref           #2.#27         // Pair.first:Ljava/lang/Object;
   #8 = Class              #28            // java/lang/String
   #9 = Methodref          #29.#30        // java/io/PrintStream.println:(Ljava/lang/String;)V
  #10 = Class              #31            // Main
  #11 = Class              #32            // java/lang/Object
  #12 = Utf8               <init>
  #13 = Utf8               ()V
  #14 = Utf8               Code
  #15 = Utf8               LineNumberTable
  #16 = Utf8               main
  #17 = Utf8               ([Ljava/lang/String;)V
  #18 = Utf8               SourceFile
  #19 = Utf8               Main.java
  #20 = NameAndType        #12:#13        // "<init>":()V
  #21 = Utf8               Pair
  #22 = Utf8               a
  #23 = Utf8               b
  #24 = NameAndType        #12:#33        // "<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
  #25 = Class              #34            // java/lang/System
  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;
  #27 = NameAndType        #37:#38        // first:Ljava/lang/Object;
  #28 = Utf8               java/lang/String
  #29 = Class              #39            // java/io/PrintStream
  #30 = NameAndType        #40:#41        // println:(Ljava/lang/String;)V
  #31 = Utf8               Main
  #32 = Utf8               java/lang/Object
  #33 = Utf8               (Ljava/lang/Object;Ljava/lang/Object;)V
  #34 = Utf8               java/lang/System
  #35 = Utf8               out
  #36 = Utf8               Ljava/io/PrintStream;
  #37 = Utf8               first
  #38 = Utf8               Ljava/lang/Object;
  #39 = Utf8               java/io/PrintStream
  #40 = Utf8               println
  #41 = Utf8               (Ljava/lang/String;)V
{
  public Main();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 4: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=4, locals=2, args_size=1
         0: new           #2                  // class Pair
         3: dup
         4: ldc           #3                  // String a
         6: ldc           #4                  // String b
         8: invokespecial #5                  // Method Pair."<init>":(Ljava/lang/Object;Ljava/lang/Object;)V
        11: astore_1
        12: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;
        15: aload_1
        16: getfield      #7                  // Field Pair.first:Ljava/lang/Object;
        19: checkcast     #8                  // class java/lang/String
        22: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        25: return
      LineNumberTable:
        line 6: 0
        line 7: 12
        line 8: 25
}
SourceFile: "Main.java"

```java
public class Main {
    public static void main(String[] args) {
        B b=new B();
        Integer a=b.set(123);
        C c=new C();
        Integer d=(Integer) c.set(123);
    }

}

class A<T>{
    public T set(T a){
        return a;
    }
}

class B extends A<Integer>{
    public Integer set(Integer a){
        System.out.println("B");
        return a;
    }
}

class C{
    public Object set(Integer a){
        return a;
    }
}

/*
泛型类或泛型方法，在编译后发生类型擦除（可通过class文件反编译查看），即类型变量用第一个类型参数代替（没有的话用Object）。
在实际使用时，JVM会调用checkcast强制类型转换

泛型方法也会发生类型擦除
public Integer set(Integer a){
        System.out.println("B");
        return a;
    }
会变成
public Object set(Object a){
        System.out.println("B");
        return a;
    }

当泛型类被继承，同时泛型类中的泛型方法被重写时，
类型擦除破坏了多态，子类中是set(Integer a)父类中是set(Object a),JVM会自动生成一个桥接方法
public Object set(Object a){
        set((Integer) a);
    }
返回的时候JVM也会对调用checkcast强制类型转换

 */
```

[3分钟快速搞懂java的桥接方法](https://www.cnblogs.com/heihaozi/p/14142671.html)

