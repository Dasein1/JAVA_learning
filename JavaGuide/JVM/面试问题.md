[a](https://www.bilibili.com/video/BV1S34y1m7sX?p=61&vd_source=7116afddac4acaa2875e31b432e7f0ed)

# JAVAP查看字节码文件 Jclasslib插件


# 1.请解释一下对象的创建过程？（半初始化）
![](images/2022-08-14-21-46-40.png)
0: 开辟空间存放T实例（成员变量为默认值）
3：调用T的初始化方法
7：将t和实例建立联系

# 2.DCL单例（Double Check Lock）到底需不需要volatile？
volatile: 修饰一个变量时，表示进程间可见和禁止重排序
==什么是重排序？==
表示这块内存的
![](images/2022-08-14-21-55-23.png)
==什么是DCL单例==
![](images/2022-08-14-22-15-19.png)
https://www.zhihu.com/question/308850392


乐观锁 ABA问题
==CAS(Compare And Swap)== 自选琐 乐观锁   替代重量级琐的一种上锁方式
比如有一个原来的值为0，有一堆线程对其进行递增，一般为了保持线程一致性需要对++进行上锁，但是有一种简单的方式可以不用上synchronized。
==比较并交换==：将0读到自己线程的内存里来，将0改为1，将1写回去的时候，先判断原来的0是不是依然为0，如果发现已经被别的线程改为8了，那就将8拿过来改为9再往回设置看是不是依然为8
==ABA问题==：0可能被线程2改为8
后，被线程3改回为0，在线程1看来0没有变化。简单的值ABA问题没有影响，但是引用类型则有可能影响业务逻辑。
    如何解决：增加一个值，版本号

![](images/2022-08-15-12-22-15.png)


# 3.对象在内存中的存储布局
共4个部分，markword(8字节)和Class pointer(4字节)共同构成Object Header
Class pointer指向T.class
padding是指整个字节数不能被8整除，padding补全是指能被8整除，读写起来效率较高
![](images/2022-08-15-13-37-35.png)
## 使用JOL查看对象布局

# 4.对象头包括什么？
## markword：
    1.锁信息
    2.GC
    3.HashCode（Identity HashCode）
        
## classpointer：
    为什么大多时候是4字节有时是8字节，CPU有三个总线，数据总线，地址总线，控制总线，对于64位CPU的地址总线，内存往往没有8字节大的地址去寻址，则压缩为32位（4字节），当内存超过32G时，则膨胀为8字节。



# 5.对象怎么定位？
## 什么是对象定位？
```java
    T t=new T();
```
t怎么找到new出来的T实例就是对象定位
## 两种方式：
直接指针：是直接指向类型数据指针
句柄方式：指向一组指针，第一个是实例数据指针，第二个是类型数据指针
![](images/2022-08-15-14-02-30.png)

## 句柄方式的优势是什么？
GC在进行复制时t的值不需要变，方便GC回收

## 什么是GC复制？
一个对象new出来放在年轻代，经过一定的年龄之后会放到老年代，所以对象在内存里面有复制的过程

# 6：对象怎么分配？
1.对象优先分配在栈上，好处：回收的时候不需要GC的介入，效率非常高
有一些对象不是很大(Xss设置最大栈的大小)而且不存在逃逸，那么它就可以被分配在栈上
2.如果栈上分配不下怎么办？
如果很大，放到老年代，经过FGC该对象才会被回收
3.如果不大，则放到线程本地缓冲区TLAB（ThreadLocalAllocationBuffer）
4.如果线程本地缓冲区分配不下，就分配到伊甸区
5.分配在伊甸区的对象会经历YGC清除，如果未被清除则进入Surviver1区，再经历YGC清除并涨年龄，年龄够大就进入老年区（默认是15岁，可以通过--XX:MaxTenuringThreshold设置），不够大则进入Surviver2区，再经历YGC清除并涨年龄，年龄够大就进入老年区，不够大则进入Surviver1区，循环往复。
![](images/2022-08-15-14-52-43.png)
## 什么是对象不存在逃逸？
对象只在m2方法里存活，没有别人可以访问到他
![](images/2022-08-15-14-29-43.png)
存在逃逸的情况：
m1方法用到了m2中new的对象
在方法内创建对象，并且return进行传出，或者赋值到外部的变量。

## 什么是线程本地缓存区？
假设有T1、T2、T3线程，它们在JVM启动后都会往伊甸区分配对象，它们有可能去抢同一个位置（碰撞指针），JVM需要花额外CPU资源去协调，与其这样不如给它们每个线程一个自己的小空间，自己的线程分配对象时优先往TLAB分配


# 7.一个Object占多少字节？
```java
Object o=new Object();
```
markword8个字节，classpointer4个字节，padding4个字节，共16个字节
 
![](images/2022-08-20-14-19-50.png)

# 8.Class对象是在堆里还是在方法区？
![](images/2022-08-15-15-01-35.png)
method area是接口，perm Generation（JDK1.7）和meta space（JDK1.8）是实现类
![](images/2022-08-15-15-04-40.png)
class对象在堆里方便我们做反射用


# 9.类加载加载过程？
类加载到方法区
方法区里面一块是代码 
另一块存放类的信息等

loading： 将class文件二进制字节装到内存里  
linking:
    verification：验证是否符合class文件标准
    preparation：将class文件静态变量赋默认值
    resolution：常量池的符号引用转换为直接的内存地址
initializing：静态变量赋为初始值，调用静态代码块

# 10.类加载器
类加载器的功能就是class文件的二进制字节存到内存里去
java8以及以前的版本会用到三种类加载器：
    1.启动类加载器，主要加载java的核心库，即lib目录下的所有class
    2.扩展类加载器，主要加载lib\ext目录的所有class
    3.应用类加载器，主要加载用户类路径上所有的类库

# 11.双亲委派机制？
https://blog.csdn.net/axiaobaoa/article/details/125011774
## 过程是怎样？
如果一个类加载器收到了类加载请求，它首先不会自动去尝试加载这个类，而是把这个类委托给父类加载器去加载，每一层依次这样，因此所有的类加载请求都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成该加载请求（找不到所需的类）时，这个时候子加载器才会尝试自己去加载。
## 有什么优点？
1.避免了类的重复加载：每层类加载器在加载时会判断是否已经加载过，如果加载过就不再重复加载。
2.保护了程序的安全性，防止核心的API被修改

# 12.class文件结构
https://blog.csdn.net/HouXinLin_CSDN/article/details/108808367?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-108808367-blog-111205954.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-108808367-blog-111205954.pc_relevant_default&utm_relevant_index=5

# 12.方法区存放什么？
方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码等数据。
## 方法区和永久代以及元空间是什么关系？



# 13.堆
## 概述
一个JVM实例只有一个堆内存，当JVM启动的时候创建，是内存管理的核心区域，它是一个物理上不连续逻辑上连续的内存空间，所有线程共享JAVA堆，方法结束后，堆中的对象不会马上被删除，仅在垃圾回收的时候被删除

## 分区？
    1.新生代，新生代又分为伊甸区、幸存者0区、幸存者1区
    2.老年代
    3.永生代（JDK1.7之前是PermGen实现，JDK1.8以后是元空间实现，使用的是直接内存）
    为什么用元空间替换永久代？
    永久代受JVM本身固定大小限制，元空间受本机可用内存限制
##  对象怎么分配？
    看第6点

## 堆容易出现什么错误？
    OutOfMemoryError:
    Java.lang.OutOfMemoryError: GC Overhead Limit Exceeded
        GC使用了超过98%的时间只回收了不到2%的内存
    java.lang.OutOfMemoryError: Java heap space
        堆内存空间不足以存放新创建的对象（最大堆内存可以通过-Xmx设置）


# 14.运行时常量池
## 怎么来的？装了些啥？
class文件中有常量池表，存放了各种字面量和符号引用（字面量有整数、浮点数、字符串，符号引用有类、字段、方法、接口方法），常量表会在类加载后存放到方法区的运行时常量池

## 会报什么错？
是方法区的一部分，所有受方法区内存限制，无法申请到内存会报OutOfMemoryError


# 15.字符串常量池
## 为什么要有字符常量池？
避免字符串的重复创建

## 字符串常量池在哪里？
JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。


# 16.直接内存
NIO(New Input/Output)类
JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。


