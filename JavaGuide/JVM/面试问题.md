[a](https://www.bilibili.com/video/BV1S34y1m7sX?p=61&vd_source=7116afddac4acaa2875e31b432e7f0ed)
# 1.请解释一下对象的创建过程？（半初始化）
![](images/2022-08-14-21-46-40.png)
0: 开辟空间存放T实例（成员变量为默认值）
3：调用T的初始化方法
7：将t和实例建立联系

# 2.DCL单例（Double Check Lock）到底需不需要volatile？
volatile: 修饰一个变量时，表示进程间可见和禁止重排序
==什么是重排序？==
表示这块内存的
![](images/2022-08-14-21-55-23.png)
==什么是DCL单例==
![](images/2022-08-14-22-15-19.png)
https://www.zhihu.com/question/308850392


乐观锁 ABA问题
==CAS(Compare And Swap)== 自选琐 乐观锁   替代重量级琐的一种上锁方式
比如有一个原来的值为0，有一堆线程对其进行递增，一般为了保持线程一致性需要对++进行上锁，但是有一种简单的方式可以不用上synchronized。
==比较并交换==：将0读到自己线程的内存里来，将0改为1，将1写回去的时候，先判断原来的0是不是依然为0，如果发现已经被别的线程改为8了，那就将8拿过来改为9再往回设置看是不是依然为8
==ABA问题==：0可能被线程2改为8
后，被线程3改回为0，在线程1看来0没有变化。简单的值ABA问题没有影响，但是引用类型则有可能影响业务逻辑。
    如何解决：增加一个值，版本号

![](images/2022-08-15-12-22-15.png)


# 3.对象在内存中的存储布局
共4个部分，markword(8字节)和Class pointer(4字节)共同构成Object Header
Class pointer指向T.class
padding是指整个字节数不能被8整除，padding补全是指能被8整除，读写起来效率较高
![](images/2022-08-15-13-37-35.png)
## 使用JOL查看对象布局

# 4.对象头包括什么？
## markword：
    1.锁信息
    2.GC
    3.HashCode（Identity HashCode）
## classpointer：
    为什么大多时候是4字节有时是8字节，CPU有三个总线，数据总线，地址总线，控制总线，对于64位CPU的地址总线，内存往往没有8字节大的地址去寻址，则压缩为32位（4字节），当内存超过32G时，则膨胀为8字节。



# 5.对象怎么定位？
## 什么是对象定位？
```java
    T t=new T();
```
t怎么找到new出来的T实例就是对象定位
## 两种方式：
直接指针：是直接指向类型数据指针
句柄方式：指向一组指针，第一个是实例数据指针，第二个是类型数据指针
![](images/2022-08-15-14-02-30.png)

## 句柄方式的优势是什么？
GC在进行复制时t的值不需要变，方便GC回收

## 什么是GC复制？
一个对象new出来放在年轻代，经过一定的年龄之后会放到老年代，所以对象在内存里面有复制的过程

# 6：对象怎么分配？
1.对象优先分配在栈上，好处：回收的时候不需要GC的介入，效率非常高
有一些对象不是很大(Xss设置最大栈的大小)而且不存在逃逸，那么它就可以被分配在栈上
2.如果栈上分配不下怎么办？
如果很大，放到老年代，经过FGC该对象才会被回收
3.如果不大，则放到线程本地缓冲区TLAB（ThreadLocalAllocationBuffer）
4.如果线程本地缓冲区分配不下，就分配到伊甸区
5.分配在伊甸区的对象会经历YGC清除，如果未被清除则进入Surviver1区，再经历YGC清除并涨年龄，年龄够大就进入老年区，不够大则进入Surviver2区，再经历YGC清除并涨年龄，年龄够大就进入老年区，不够大则进入Surviver1区，循环往复。
![](images/2022-08-15-14-52-43.png)
## 什么是对象不存在逃逸？
对象只在m2方法里存活，没有别人可以访问到他
![](images/2022-08-15-14-29-43.png)
存在逃逸的情况：
m1方法用到了m2中new的对象

## 什么是线程本地缓存区？
假设有T1、T2、T3线程，它们在JVM启动后都会往伊甸区分配对象，它们有可能去抢同一个位置（碰撞指针），JVM需要花额外CPU资源去协调，与其这样不如给它们每个线程一个自己的小空间，自己的线程分配对象时优先往TLAB分配


# 7.一个Object占多少字节？
```java
Object o=new Object();
```
markword8个字节，classpointer4个字节，padding4个字节，共16个字节
 
![](images/2022-08-20-14-19-50.png)

# 8.Class对象是在堆里还是在方法区？
![](images/2022-08-15-15-01-35.png)
method area是接口，perm Generation（JDK1.7）和meta space（JDK1.8）是实现类
![](images/2022-08-15-15-04-40.png)
class对象在堆里方便我们做反射用




# 执行顺序
https://blog.csdn.net/sunforraining/article/details/79008171

[静态变量的循环依赖]https://www.cnblogs.com/jason1990/p/11856296.html
https://www.cnblogs.com/leiqiannian/p/7922824.html#:~:text=%E4%B8%80%E8%88%AC%E9%A1%BA%E5%BA%8F%EF%BC%9A%E9%9D%99%E6%80%81%E5%9D%97%EF%BC%88%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89%E2%80%94%E2%80%94%3E%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E2%80%94%E2%80%94%3E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%3E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%201%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88%E5%8F%AA%E5%8A%A0%E8%BD%BD%E4%B8%80%E6%AC%A1%EF%BC%89%202%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E5%B0%B1%E5%8A%A0%E8%BD%BD%E4%B8%80%E6%AC%A1%EF%BC%893%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8%E6%89%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%89%80%E4%BB%A5%E6%9C%80%E5%90%8E%E7%BB%93%E6%9E%9C%E6%B2%A1%E6%9C%89e%20public%20class%20Print%20%7B%20public,System.%20out.print%20%28s%20%2B%20%22%20%22%29%3B%20%7D%20%7D
如果类还没有被加载： 
1、先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。 
2、执行子类的静态代码块和静态变量初始化。 
3、执行父类的实例变量初始化 
4、执行父类的构造函数 
5、执行子类的实例变量初始化 
6、执行子类的构造函数 
如果类已经被加载： 
则静态代码块和静态变量就不用重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。