==Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来。==
可以使用Object类型的变量引用任何类型的对象：
```java
Object obj=new Employee("Harry Hacker",3500);
//如果想对其中的内容进行具体的操作怎么办？ 需要强制类型转换成对象的原始类型
Employee e=(Employee) obj;
```
注意：所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。
```java
Employee[] staff =new Employee[10];
obj=staff;
obj=new int[10];
```

# 1.equals方法
在Object类中，这个方法将判断==两个对象是否具有相同的引用==。
下面用euqals方法在Employee类中实现与另一个对象的比较：
```java
public class Employee{
    public boolean equals(Object otherObject){
        //快速判断两个对象的引用是否一致
        if(this == otherObject) return true;

        //如果另一个对象的引用为空，肯定不相等
        if (otherObject == null) return false;

        //如果两个对象的类不相同，肯定不相等
        if(getClass() != otherObject.getClass())
            return false;
        
        //现在我们知道另一个对象是非null的Employee对象
        Employee other=(Employee) otherObject;

        //测试两个对象的域值是否相等
        return name.equals(other.name) && salary==other.salary && hireDay.equals(other.hireDay);
    }
}
```
==注意==：为了防备name或hireDay可能为null的情况，需要使用Objects.equals方法。
1.如果两个参数都为null，返回true
2.如果只有其中一个参数为null,则返回false
3.如果两个参数都不为null，则调用a.equals(b)
```java
//对Employee.equals方法的最后一条语句的改写
return Objects.equals(name,other.name) && salary==other.salary && Object.equals(hireDay,other.hireDay);
```

在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等
```java
public class Manager extends Employee 
{
    public boolean equals(Object otherObject) 
    {
if (!s叩er equals(otherObject)) return false; 
// super.equals checked that this and otherObject belong to the same class 
    Manager other = (Manager) otherObject; 
    return bonus == other.bonus;
    }
}
```

# 2.相等测试与继承
## equals方法应具有下面的特性
1）==自反性==:对于任何非空引用 x, x.equals(x)应该返回 true。
2）==对称性==：对于任何引用 x 和 y, 当且仅当 y.equals(x) 返回 true, x.equals(y) 也应该返 回 true。
3）==传递性==:对于任何引用x、y和z, 如果 x.equals(y)返回true，y.equals(z)返回true, x.equals(z)也应该返回true。
4）==一致性==:对于任意非空引用x，x.equals(null)应该返回false


## 如果隐式和显式的参数不属于同一个类，equals方法将如何处理？
若用instanceof进行检测：
```java
if ( !(otherObject instanceof Employee)) return false;
```
若e是一个Employee对象，m是一个Manager对象，并且两个对象具有相同的姓名、薪水和雇佣日期。
如果在Employee.equals中用instanceof进行检测，则该方法返回true。
```java
e.equals(m);
```
这意味着反过来调用：
```java
m.equals(e);
```
也需要返回true。这意味着什么呢？  Manager类的equals方法必须能够用自己与任何一个Employee对象进行比较，并且不考虑经理拥有的那部分特有信息。


### 如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测。
如Manager类的对象需要比较它特有的奖金域

### 如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样可以在不同子类的对象之间进行相等比较。
如Employee类对象和子类Manager类对象只需要比较公有的域


## 想了个测试
```java
public class test {
    public static void main(String[] args){
        Manager a=new Manager();
        Manager b=new Manager();
        System.out.println(a.equals(b));
    }
}

class Employee{
    String name="s";
    public boolean equals(Object otherObject){
        //如果两个对象的类不相同，肯定不相等
        System.out.println("我自己的class："+getClass());
        System.out.println("他的class："+otherObject.getClass());
        if(getClass() != otherObject.getClass())
            return false;
        Employee other=(Employee) otherObject;
        return name.equals(other.name);
    }
}

class Manager extends Employee{
    int bonus=2;
    public boolean equals(Object otherObject)
    {
        if (!super.equals(otherObject)) return false;
// super.equals checked that this and otherObject belong to the same class
        Manager other = (Manager) otherObject;
        return bonus == other.bonus;
    }
}
```
一开始觉得调用super.equals()时，getClass()的判断这里会返回false


# 3.hashCode方法
散列码（hash code）：由对象导出的一个整型值。由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。
==字符串的散列码是由内容导出的==
==在StringBuffer类中没有定义hashCode方法，散列码为默认值==


# 4.toString方法
==只要对象与一个字符串通过操作符“+”连接起来，Java编译就会自动地调用toString方法。==
例如：在调用x.toString()的地方可以用""+x替代。 ==好处==：与toString不同的是，如果x是基本类型，这条语句照样能执行。

## 打印数组
数组继承了Object类的toString方法，数组类型将按照旧的格式打印。例如：
```java
int[]  luckyNumbers={2,3,5,7,11,13};
String s=""+luckyNumbers;
System.out.println(s);
```
修正方式：
```java
String s = Arrays.toString(luckyNumbers);
//打印多维数组
String s = Arrays.deepToString;
```
## 为什么定义toString方法？
用户能够获得一些有关对象状态的必要信息。
```java
System,out .println("Current position = " + position);
Logger,global,info("Current position = " + position);
```
