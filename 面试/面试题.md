# MYSQL
## 1.MySQL的隔离级别有哪些？
### 什么是隔离？
定义规则用于限定事务内外哪些改变是可见的，哪些改变是不可见的。
级别越低效率越高，数据越不安全

### 有哪些隔离级别？
READ UNCOMMITTED 读取未提交内容    脏读、不可重复读
事务开启后，可以随便读别的事务修改的数据
READ UNCOMMITTED 读取提交内容（大多数数据库系统默认隔离级别）    不可重复读
事务开启后，可以读到别人提交的数据   
REPEATABLE READ（MySQL默认隔离级别）  可重复读   在一个事务里重复读取一个数据都会一致   产生幻读问题
事务开启后，读不到别人提交的数据
SERIALIZABLE 可串行化
在每个读的数据行加上锁，强制事务排序



### 不同的隔离级别会产生哪些不同的数据安全问题？
脏读：
不可重复读：同一个事务里对同一个数据读两次的结果不一致，例子：事务A在两次查询中间，该数据被事务B修改
幻读：发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

## 2.MySQL复制原理
原理：
    （1）master服务器写binlog日志
    （2）slave服务器探测Master是否改变，如果发生改变，开启IO/Thread请求master二进制事件
    （3）同时主节点为每个I/O线程启动一个dump线程，保存至中继日志，从节点启动SQL线程从中继日志中读取二进制日志，在本地重放，最后I/OThread和SQL Thread将进入睡眠状态





## 3.聚簇索引和非聚簇索引区别
数据和索引放在一起就是聚簇，否则就是非聚簇
innodb中既有聚簇索引也有非聚簇索引
myisam中只有非聚簇索引


## 4.索引的基本原理
### 为什么要索引？
一般的应用系统，读写比例在10：1左右，复杂的查询操作最容易出问题，对查询语句的优化是重中之重，索引则是为了加速查询
### 什么是索引？
索引也叫一种“键”，是存储引擎用于快速找到记录的一种数据结构，相当于字典的音序表
### 索引的原理
本质都是：通过不断缩小想要获取数据的范围来筛选出最终想要的结果。


## 5.mysql索引结构有哪些？

## 6.谈谈对mysql索引的理解
mysql里面存在对应的一些索引，索引的数据结构是通过B+树或Hash表生成的，不同类型的索引是与存储引擎相关的，myisam和innodb存储引擎对对应的数据结构是B+树，Memory存储引擎对应的数据结构是Hash表（不同的存储引擎表示的是数据在磁盘上不同的组织形式）。使用B+树的原因是索引里面存储的是keyvalue数据，key就是列值，value是一行的记录，当选择KV格式存储的时候可以用hash表，二叉树，AVL树，红黑树，B+树，如果用二叉树最后都会导致整棵树变高，树变高会影响我们IO的次数，从而影响我们访问数据的效率，使用B+树可以在某一个数据节点里尽可能多的存储数据，让这棵树变低。在mysql里，有主键索引，唯一索引，普通索引，组合索引。在主键索引和组合索引时，会存在一系列回表，覆盖索引，最多匹配，索引下推的细节。使用SQL语句的时候，还可以通过索引的点来进行优化，提高对应数据的访问效率。

[B+树详解](https://blog.csdn.net/qq_41999455/article/details/106138619)

[mysql索引面试题](https://www.bilibili.com/video/BV14K4y1W73B?p=5&spm_id_from=pageDriver&vd_source=7116afddac4acaa2875e31b432e7f0ed)

## 7.mysql锁的类型有哪些？
基于锁的属性分类：共享锁（读锁）、排他锁（写锁）
基于锁的粒度分类：行级锁、表级锁、页级锁、记录锁、间隙锁、临建锁
基于锁的状态分类：意向共享锁、意向排它锁


[索引下推](https://www.jb51.net/article/222444.htm)
什么时候出现索引下推？




## 8.MySQL三大日志（binlog、redo log和undo log）
###  redo log
MySQL挂了之后或宕机之后，重启时，innodb存储引擎会使用redo log恢复数据，保证数据的持久性和完整性
运行机制是这样的：
    我们在查询的时候，会从硬盘把一页的数据加载出来（默认16kb）放入到BufferPool中，这样做是因为之前被读取过的数据很可能被下一次读取，所以后续的查询会先从BufferPool中去找，找不到再去硬盘中查找，减少IO的开销。同样的，我们的redo log也有一个重做日志缓存，当我们去修改数据时，会先把修改命令记录在redolog buffer中，然后根据刷盘时机的具体策略来把缓存的内容写入到文件系统缓存（page cache），再调用fsync刷盘。
    事务提交时的三种策略：0不刷、1刷、2只写入page cache
    InnoDB引擎有一个后台线程每隔1秒就会去刷盘，另外redolog buffer达到设置的size的一半也会主动刷盘
[详细了解MySQL的redo日志](https://baijiahao.baidu.com/s?id=1720858732021016311&wfr=spider&for=pc)
![](images/2022-09-04-22-25-05.png)


### undo log
sql执行失败之后回滚数据，保证事务的原子性





### binlog
是逻辑日志，记录的是语句的原始逻辑，类似于“给ID=2这行的c字段加1”，属于MYSQL server层，用于数据备份，主从同步
#### 它是逻辑日志，记录内容是语句的原始逻辑，什么样子的？





# spring springboot
## 1.Springboot启动
    1.创建SpringApplication对象
        1）进入run()方法，run方法中new创建了一个SpringApplication实例
        2）创建实例时的关键步骤：
            从类路径中推断并设置应用类型。应用类型有三种：非web应用，基于servlet的web应用和基于REACTIVE的web应用。
            从SpringFactories文件中找到配置的事件监听器,并保存起来
            推断运行主类
执行run方法


    总结
    Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean。


答题技巧：
总：当前问题回答的是哪些具体的点
分：以1，2，3，4，5的方式分细节去描述相关的知识点，如果有哪些点不清楚，直接忽略过去，突出一些二技术名词（核心概念，接口，类，关键方法）
    避重就轻

# 1.Spring IOC的理解，原理与实现？
## 总
控制反转：理论思想，原来的对象是由使用者来进行控制，有了spring后，可以把整个对象交给spring来帮我们进行管理
DI：依赖注入，把对应的属性的值注入到具体的对象中，@Autowired，populateBean完成属性值的注入


容器：存储对象，使用map结构来存储（），在spring中一般存在三级缓存（循环依赖问题），singletonObject存放完整的Bean对象，整个Bean的生命周期，从创建到使用到销毁的过程全部都是由容器管理（Bean的生命周期）

## 分
1.一般聊到ioc容器的时候要涉及到容器的创建过程（beanFactory,DefaultListableBeanFactory）
    ioc容器有一个最上层的根接口叫做beanFactory，它里面只是一个接口，没有提供对应的子类实现，我们在实际中最普遍调用的就是DefaultListableBeanFactory，我们在使用的时候也会优先创建bean工厂，向bean工厂中设置一些参数（BeanPostProcessor，Aware接口的子类)等等属性
2.加载解析bean对象，准备要创建的bean对象的定义对象beanDefinition(xml或者注解的解析过程)
3.beanFactoryPostProcessor的处理，此处是扩展点，PlaceHolderConfigureSupport,ConfigurationClassPostProcessor
4.BeanPostProcessor的注册功能，方便后续对bean对象完成具体的扩展功能
5.通过反射的方式将BeanDefinition对象实例化成具体的bean对象。
6.bean对象的初始化过程（填充属性，调用aware子类的方法，调用BeanPostProcessor前置处理方法，调用init-method方法，调用BeanPostProcessor的后置处理方法）
7.生成完整的bean对象，通过getBean方法可以直接获取
8.销毁过程


![](images/2022-09-02-12-03-41.png)


# 2.谈一下IOC的底层实现
底层实现：工作原理，过程，数据结构，流程，设计模式，设计思想
你对他的理解，和你了解过的实现过程
反射，工厂，设计模式 关键的几个方法
1.先通过createBeanFactory创建出一个Bean工厂（DefaultListableBeanFactory）
2.开始循环创建对象，因为容器中的bean默认是单例的，所有优先通过getBean,doGetBean从容器中找，找不到的话
3.通过createBean，doCreateBean方法，以反射的方式创建对象，一般情况下使用的是无参的构造（getDeclaredConstructor，newInstance）
4.进行对象的属性填充populateBean
5.进行其他的初始化操作（initializingBean）



# 3.描述一下bean的生命周期？
![](images/2022-09-02-13-35-34.png)

# 4.Spring是如何解决循环依赖的问题？
# 执行顺序
https://blog.csdn.net/sunforraining/article/details/79008171

[静态变量的循环依赖]https://www.cnblogs.com/jason1990/p/11856296.html
https://www.cnblogs.com/leiqiannian/p/7922824.html#:~:text=%E4%B8%80%E8%88%AC%E9%A1%BA%E5%BA%8F%EF%BC%9A%E9%9D%99%E6%80%81%E5%9D%97%EF%BC%88%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89%E2%80%94%E2%80%94%3E%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E2%80%94%E2%80%94%3E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%3E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%201%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88%E5%8F%AA%E5%8A%A0%E8%BD%BD%E4%B8%80%E6%AC%A1%EF%BC%89%202%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E5%B0%B1%E5%8A%A0%E8%BD%BD%E4%B8%80%E6%AC%A1%EF%BC%893%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8%E6%89%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%89%80%E4%BB%A5%E6%9C%80%E5%90%8E%E7%BB%93%E6%9E%9C%E6%B2%A1%E6%9C%89e%20public%20class%20Print%20%7B%20public,System.%20out.print%20%28s%20%2B%20%22%20%22%29%3B%20%7D%20%7D
如果类还没有被加载： 
1、先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。 
2、执行子类的静态代码块和静态变量初始化。 
3、执行父类的实例变量初始化 
4、执行父类的构造函数 
5、执行子类的实例变量初始化 
6、执行子类的构造函数 
如果类已经被加载： 
则静态代码块和静态变量就不用重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。


```java
public class Main{
    public static void main(String[] args) {
        new F("asdads");
    }
}


class E{
    private  String e;
    public   String a="asd";
    private  String b="asd";
    E(String e){
        this.e=e;
    }
    public void speak(){
        System.out.println("我是父类");
    }
}

class F extends E{
    F(String e){
        super(e);
        System.out.println(e);
        System.out.println(super.a);
        super.speak();
    }
    public void speak(){
        System.out.println("我是子类");
    }
}
```



# 4.Spring是如何解决循环依赖的问题的？
三级缓存，提前暴露对象，aop
总：什么是循环依赖问题,A依赖B，B依赖A
分：先说明bean的创建过程：实例化、初始化（填充属性）
    1、先创建A对象，实例化A对象，此时A对象中的b属性为空，填充属性b
    2、从容器中查找B对象，如果找到了，直接赋值不存在循环依赖问题，找不到直接创建B对象
    3、实例化B对象，此时B对象中的a属性为空，填充属性a
    4、从容器中查找A对象，找不到，直接创建
    形成闭环的原因

    此时，如果仔细琢磨的化，会发现A对象是存在的，只不过此时的A对象不是一个完整的状态，只完成了实例化但是未完成初始化，如果在程序调用过程中，拥有了某个对象的引用，能否在后期给他完成复制操作，可以优先把非完整状态的对象优先赋值，等待后续操作来完成赋值，相当于提前暴露了某个不完整对象的引用，相当于提前暴露了某个不完整对象的引用，所以解决问题的核心在于实例化和初始化分开操作，这也是解决循环依赖问题的关键，
    当所有的对象都完成实例化和初始化操作之后，还要把完整对象放到容器中，此时在容器中存在对象的几个状态，完成实例化但未完成初始化，完整状态，因为都在容器中，所以要使用不同的map结构来进行存储，此时就有了一级缓存和二级缓存，如果一级缓存中有了，那么二级缓存中就不会存在同名的对象，因为它们的查找顺序是1、2、3这样的方式来查找的。一级缓存中放的是完整的对象，二级缓存中放的是非完整对象

       为什么需要三级缓存？三级缓存的value类型是ObjectFactory，是一个函数式接口，存在的意义是保证在整个容器的运行过程中同名的bean对象只能有1个
    
       如果一个对象需要被代理，或者说需要生成代理对象，那么要不要优先生成一个普通对象？ 要
       
       普通对象和代理对象是不能同时出现在容器中的，因此当一个对象需要被代理的时候，就要使用代理对象覆盖掉之前的普通对象，在实际的调用过程中，是没有办法确定什么时候对象被使用，所以就要求当某个对象被调用的时候，优先判断此对象是否需要被代理，类似一种回调机制的实现，因此传入lambda表达式的时候，可以通过lambda表达式来执行对象的覆盖过程，getEarlyBeanReference()

       因此，所有的bean对象在创建的时候都要优先放到三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象。

## 4.1 缓存的放置时间和删除时间
    三级缓存：createBeanInstance之后，addSingletonFactory
    二级缓存：第一次从三级缓存确定对象是代理对象还是普通对象，同时删除三级缓存getSingleton
    一级缓存：生成完整对象之后放到一级缓存，删除二三级缓存：addSingleton



# 5.BeanFactory与FactoryBean有什么区别？
 ==相同点==：都是用来创建bean对象的
 ==不同点==：使用BeanFactory创建对象的时候，必须要遵循严格的生命周期流程，太复杂了；如果想要简单的定义某个对象的创建，同时创建完成的对象想交给spring来管理，那么就需要实现FactoryBean接口了
    isSingleton:是否是单例对象
    getObjectType:获取返回对象的类型
    getObject：自定义创建的过程(new,反射，动态代理)
不管最终用哪种方式创建，最后创建的对象都会由spring管理
 

# 6. Spring中用到的设计模式？
单例模式：bean默认都是单例的
原型模式：指定作用域为prototype
工厂模式：BeanFactory
模板方法：postProcessBeanFactory,onFresh,initPropertyValue
策略模式：XmlBeanDefinitionReader,PropertiesBeanDefinitionReader
观察者模式：listener,event,multicast
适配器模式：Adapter
装饰者模式：BeanWrapper
责任链模式：使用AOP的时候会先生成一个拦截器
代理模式：动态代理
委托者模式：delegate


# 7. Spring的AOP的底层实现原理？
aop是ioc的一个扩展功能， 先有的ioc，再有的aop，只是在ioc的整个流程中新增的一个扩展点：BeanPostProcessor
总：aop概念，应用场景（事务，日志），实现用的动态代理
分：bean的创建过程中有一个步骤可以对bean进行扩展实现，aop本身就是一个扩展功能，所以在BeanPostProcessor的后置方法中来进行实现
    1.代理对象的创建过程（advice，切面，切点）
    2.通过jdk或cglib的方式来生成代理对象




# 计算机网络

## 讲讲传输层 TCP/UDP
实际上在网络中进行通信的是两端的进程，那么传输层做的就是把为两端的进程提供直接的通信服务（建立的是逻辑通信通道），根据应用的不同需求，传输层提供了两种不同的协议，面向连接的TCP和无连接的UDP。

既然传输层是给不同的进程提供服务的，那么考虑到不同操作系统的进程标识符PID不同的，就必须用统一的方法对TCP/IP体系的进程进行标识，即端口号（65535，16bit）。
    熟知端口号：0~1023，分配给了一些重要的应用协议，HTTP使用80，DNS使用53
    登记端口号：使用的话必须登记
    短暂端口号：留给客户端短暂使用
    
复用与分用的概念：
    复用：从上层拿过来封装
    分用：拆分了传给上层
IP数据报首部中包含了传输控制层是TCP还是UDP协议的信息。
复用时在首部标识，分用时根据标识上交给TCP或UDP
传输层根据端口号上交给相应的进程





## 三次握手，四次挥手
其中一台主机中的某个应用进程主动发起TCP连接建立，称为TCP客户。另一台主机中被动等待TCP连接建立的应用进程称为TCP服务器。我们可以将TCP建立连接的过程比喻为“握手”。 “握手”需要在TCP客户和服务器之间交换三个TCP报文段。

一开始，TCP客户和TCP服务器处于关闭状态。TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如，TCP连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序列号等，之后，就准备接收TCP客户进程的连接请求，此时，TCP服务器进程进入监听状态，等待TCP客户进程的连接请求，称为被动打开连接
TCP客户进程创建传输控制块，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段并进入同步已发送状态，TCP连接请求报文段首部中的同步位SYN被设置为1，表明这是一个TCP连接请求报文段，序号字段seq被设置为一个初始值x，作为TCP客户进程所选择的初始序号。注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号。 由于TCP连接建立是由TCP客户主动发起的，因此称为主动打开连接。TCP服务进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态。该报文段首部中的同步位SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段。序号字段seq被设置为一个初始值y，作为TCP服务器进程所选择的初始序列号。确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号的确认。注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号。TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已进入状态。该报文段首部中的确认位ACK被设置为1，表明这是一个普通的TCP确认报文段。序号字段seq被设置为x+1,这是因为TCP客户进程发送的第一个TCP报文段的序号为x，并且不携带数据，因此第二个报文段的序号为x+1。注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号。在这种情况下，所发送的下一个数据报文段的序号仍是x+1。确认号字段ack被设置为y+1，这是对TCP服务进程所选择的初始号的确认。TCP服务进程收到确认报文段后也进入连接已建立状态。现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接进行可靠的数据传输了。


## 上网过程
nc www.baidu.com
curl www.baidu.com
用户PC，DNS服务器，Web服务器，通过交换机进行互联，它们处于同一个以太网中，假设这是Web服务器的域名，DNS服务器中记录有该域名对应的IP地址。我们在用户PC中使用网页浏览器来访问Web服务器的内容，在网页浏览器的地址栏中输入Web服务器的域名，用户PC中的DNS客户端进程会发送一个DNS查询请求报文，其内容为“域名www.porttest.com所对应的IP地址是什么”，DNS查询请求报文需要使用运输层的UDP协议封装成UDP用户数据报，其UDP首部的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程，例如49152，目的端口字段的值设置为53，这是DNS服务器端进程所使用的熟知端口号。之后将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器。DNS服务器收到该数据报后，从中解封出UDP用户数据报，UDP用户数据报的端口号为53，这表明应将UDP用户数据报的数据载荷部分也就是DNS查询请求报文交付给本服务器中的DNS服务器端进程。DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址。之后会给用户PC发送DNS响应报文，其内容为"",交付给用户PC中的DNS客户端进程，解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名，所对应的IP地址为 。现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文了.HTTP服务器端进程所使用的熟知端口为80 .Web服务器向用户PC发送HTTP响应报文。

## TCP和UDP对比
UDP和TCP是TCP/IP体系结构运输层中的两个重要协议，TCP/IP体系结构应用层中的某些协议需要使用运输层的TCP提供的服务，而另一些协议需要使用运输层的UDP提供的服务 
在运输层使用UDP协议进行通信的两台主机可以随时发送数据
使用TCP协议进行同行的双方在数据传输之前必须使用“三报文握手”建立TCP连接，TCP连接建立成功后才能进行数据传输。数据传输结束后，必须使用“四报文挥手”来释放TCP连接。
UDP支持单播、多播以及广播
TCP通过“三报文握手”建立连接 ，通信双方之间好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信，TCP仅支持单播
UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界。换句话说，UDP是面向应用报文的。
TCP：发送方的TCP把应用进程交付下来的数据块仅仅看作是一连串的无结构的字节流，TCP并不知道这些待传送的字节流的含义，仅将它们编号并将它们存储在自己的发送缓存中，TCP根据发送策略，从发送缓存中提取一定数量的字节，构建TCP报文段并发送。接收方的TCP，一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中。一方面将接收缓存中的一些字节交付给应用进程。TCP不保证接收方应用进程所收到的数据块与发送方应用进程所发出的数据块具有对应大小的关系。 
TCP是面向字节流的，这是TCP实现可靠传输、流量控制、以及拥塞控制的基础。
在实际网络中，基于TCP连接的两端可以同时进行TCP报文段的发送和接收，也就是全双工通信

接收方UDP可以通过该数据报首部中的校验和字段的值检查出产生误码的情况，但仅仅丢弃该数据报，其他什么也不做，发送方也什么都不做
TCP报文段首部较长是因为需要实现可靠传输、流量控制、以及拥塞控制等服务。


时间：TCP必须通过三次握手建立连接，UDP可以随时发送数据
空间：TCP只支持单播，UDP支持单薄，多播以及广播
对交付下来的报文的处理：TCP面向字节流，拿到数据块后，存储到自己的发送缓存中，每次从发送缓存中提取一定数量的字节构建TCP报文段并发送。接收方的TCP从收到的TCP报文中取出数据载荷部分存储在接受缓存中。简而言之，不保证接收方应用进程收到的数据块与发送方应用进程发送的数据块具有对应大小的关系。 （！！！TCP面向字节流是TCP实现可靠传输、流量控制、拥塞控制的基础）








### 流量控制 拥塞控制




# 设计模式
## 工厂模式
https://baijiahao.baidu.com/s?id=1723461529698148319&wfr=spider&for=pc

# JVM
类加载过程
1.加载 2.连接  3.初始化  4.使用  5.卸载



# JVM
## 1.类加载器（Class文件如何从硬盘中到内存里？）
loading： 将class文件二进制字节装到内存里  
linking:
    verification：验证是否符合class文件标准
    preparation：将class文件静态变量赋默认值
    resolution：常量池的符号引用转换为直接的内存地址
initializing：静态变量赋为初始值，调用静态代码块


# Redis
## 1. Redis sentinal哨兵模式
Sentinel(哨兵)是用于监控redis集群中Master状态的工具，是Redis 的高可用性解决方案，sentinel哨兵模式已经被集成在redis2.4之后的版本中。

sentinel系统可以监视一个或者多个redis master服务，以及这些master服务的所有从服务；当某个master服务下线时，自动将该master下的某个从服务升级为master服务替代已下线的master服务继续处理请求

sentinel可以让redis实现主从复制，当一个集群中的master失效之后，sentinel可以选举出一个新的master用于自动接替master的工作，集群中的其他redis服务器自动指向新的master同步数据。一般建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换。其结构如下:


Redis支持主从同步机制，redis2作为redis1的slave从机，同步复制master的内容，当其中一个数据库宕机，应用服务器是很难直接通过找地址来切换成redis2，这时就用到了redis sentinal 哨兵机制。sentinal与redis1和redis2建立长连接，与主机连接是心跳机制，miaosha.jar无需知道redis1，redis2主从关系，只需ask redis sentinal，之后sentinal就response回应redis1为master，redis2为slave



一旦发生redis1坏掉或者发生网络异常，心跳机制就会破坏掉，sentinal更改redis2为master，redis1为slave，变换主从关系，然后发送change给应用服务器，然后miaosha.jar就向redis2进行get、set操作（或者redis读写分离，在master上set，slave上get）——redis 哨兵机制



总结一下：

Sentinal作用：

Master状态检测
如果Master异常，则会进行Master-Slave切换，将其中一个Slave作为Master，将之前的Master作为Slave
2.Redis集群cluster模式
一般情况下，使用主从模式加Sentinal监控就可以满足基本需求了，但是当数据量过大一个主机放不下的时候，就需要对数据进行分区，将key按照一定的规则进行计算，并将key对应的value分配到指定的Redis实例上，这样的模式简称Redis集群。

cluster集群配置有多个slave用来读，master用来写，各种redis服务器彼此知道相互关系。

cluster好处:

将数据自动切分到多个节点
当集群某台设备故障时，仍然可以处理请求
节点的fail是集群中超过半数的节点检测失效时才生效
cluster故障转移
1. 节点故障判断
首先，在Redis Cluster中每个节点都存有集群中所有节点的信息。它们之间通过互相ping-pong判断节点是否可以连接。如果有一半以上的节点去ping一个节点的时候没有回应，集群就认为这个节点宕机。

2.slave选举
当主节点被集群公认为fail状态，那么它的从节点就会发起竞选，如果存在多个从节点，数据越新的节点越有可能发起竞选。集群中其他主节点返回响应信息。

3.结构变更
当竞选从节点收到过半主节点同意，便会成为新的主节点。此时会以最新的Epoch通过PONG消息广播，让Redis Cluster的其他节点尽快的更新集群信息。当原主节点恢复加入后会降级为从节点。
————————————————
版权声明：本文为CSDN博主「安东尼的小不2」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_35580701/article/details/106972415



自我介绍
谈谈项目，遇到什么问题，怎么解决的，有什么收获
你们这个深度学习项目的数据怎么处理的，出错怎么办
第二个项目有些感兴趣，给你几分钟说下这个项目的一个目标，用了什么技术解决什么问题，还能怎么提高。（该项目应该和他们做的有一些关联，后面又仔细问了）
你觉得你在学校的项目中担当什么角色，在这个角色的扮演过程中你觉得还有哪些方面是要提高的
怎么解决团队的一些矛盾的，怎么发挥团队的优势
你觉得你有什么缺点
有什么问我的吗
