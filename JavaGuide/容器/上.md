# 概览
两大接口
Collection 接口 存放单一元素   子接口：List Set Queue
Map接口   存放键值对

# 说说 List, Set, Queue, Map 四者的区别？
是否有序、是否重复
List：有序的、可重复的
Set：无序、不可重复的
Queue: 按特定的排队规则来确定先后顺序的List
Map：使用键值对存储，key是无序的不可重复的  value是无序的可重复的

List：
ArrayList：数组
Vector：数组
LinkedList：双向链表

Set：
HashSet（无序、唯一）：基于HashMap实现
LinkedHashSet：LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。
TreeSet（有序、唯一）：红黑树（自平衡的排序二叉树）

Queue：
PriorityQueue：数组来实现二叉堆
https://blog.csdn.net/WenWu_Both/article/details/122555401
ArrayQueue： 数组+双指针

Map:
HashMap:数组+链表   JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间
LinkedMap:
Hashtable:数组+链表
TreeMap:红黑树 


# Collection 子接口之 List
## Arraylist 和 Vector 的区别?
ArrayList 底层使用 Object[ ]存储，线程不安全,所以适用频繁的查找工作，不安全也不影响
Vector  底层也是用Object[] 存储，但是线程安全，大多数成员方法都加上了synchronized锁
### Vector方法真的线程安全吗？
https://blog.csdn.net/A12115419/article/details/121145752
单个方法是安全的，但是复合操作没有解决线程安全的问题。比如一个线程在先后调用两个Vector成员方法时，当前线程有可能再完成第一个方法后时间片到期，这时其他线程可以访问该Vector对象，造成调用第二个成员方法的结果可能与预想结果不同。这时为了保证线程安全，需要加synchronized。







## Arraylist 与 LinkedList 区别?
1.都不保证线程安全
2.ArrayList用Object数组，LinkedList使用的是双向链表
3.插入和删除
4.快速随机访问
LinkedList不支持 ArrayList支持
5.内存空间占用：
ArrayList需要在列表末尾预留容量
LinkedList需要存放直接后继和直接前驱


## ArrayList 扩容机制
### 静态变量
private static final int DEFAULT_CAPACITY=10    // 默认容量为10
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA={}    // 默认空数组
### 成员变量
Object[] elementData   //  指向数组
int size  //  记录数组中对象的数量


minCapacity表示需要的最小容量
1.无参构造的elementData指向默认空数组，初次添加时分配10（minCapacity为1，再和DEFAULT_CAPACITY比较赋值10）
2.每次添加调用ensureCapacityInternal(size+1)方法
3.ensureCapacityInternal()将size+1的值作为minCapacity，
2.当minCapacity大于容器容量时，调用grow方法进行扩容
3.扩容时，int newCapacity = oldCapacity + (oldCapacity >> 1) （oldCapacity为奇数时，变为原来的1.5倍左右，偶数时，变为原来的1.5倍）

### add方法
告诉ensureCapacityInternal()方法我数组中有size对象 
告诉ensureExplicitCapacity方法我最小需要minCapacity的容量(如果elementData指向默认空数组，则minCapacity为默认容量和size+1中的最大值，否则，minCapacity为size+1)
如果现在数组长度小于minCapacity，扩容，否则不扩容

### 如何扩容？
newCapacity先变为oldCapacity的1.5倍，不够变为minCapacity
newCapacity比MAX_ARRAY_SIZE（Integer.MAX_VALUE-8）大吗？
大于则把newCapacity设为MAX_ARRAY_SIZE或Integer.MAX_VALUE


### 精简版
1.有初始容量参数构造，创建一个长度为初始容量的数组，无参构造，引用默认空数组。
2.加元素时，首先判断我的最小需求是多少，如果引用的默认空数组，那么最小需求是默认容量和size+1的最大值，否则最小需求就是size+1（==口容大小为10起步==）
3.如果数组容量够，不用扩容，不够就扩容，
4.怎么扩容？先扩容1.5倍，不够就直接将newCapacity设置为最小需求，如果newCapacity超了，那么考虑设为MAX_ARRAY_SIZE或Integer.MAX_VALUE（取决于minCapacity）



# List, Set, Queue, Map 四者的区别？
 针对存储元素的特征来回答
 是否有序 是否可重复


 ![](images/2022-04-26-23-45-45.png)
