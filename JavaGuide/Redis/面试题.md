# 1.说一下你在项目中的redis的应用场景？
    1.5大value类型：根据redis课有场景介绍
    2.基本上就是缓存
    3.token session 为的是服务无状态，看项目有哪些数据结构或对象，在单机里需要单机锁，在多级需要分布式琐，抽出来放入redis
    4.无锁化

# 2.redis是单线程还是多线程？
    1.无论什么版本，工作线程就是一个
    2.6.x高版本出现了IO多线程
    3.单线程，满足redis的串行原子，只不过IO多线程后，把输入/输出放到更多的线程里去并行，好处如下：执行时间缩短，更快；更好地压榨系统及硬件的资源（网卡能够高效的使用）
# 3.redis存在线程安全的问题吗？为什么？
    重复2的单线程串行
    redis可以保障内部串行
    外界使用的时候要保障，业务上要自行保障顺序

# 4.缓存穿透、缓存击穿、缓存雪崩
    以上问题，核心就是避免DB无效/重复请求，结合图去理解
    涉及一些架构思想上的提升

# 5.缓存如何回收的？
    1.后台在轮询，分段分批的删除那些过期的key
    2.请求的时候判断是否已经过期了
    尽量把内存无用空间收回来

# 6.缓存是如何淘汰的？
    0.内存空间不足的情况下
    1.淘汰机制里有不允许淘汰
    2.lru/lfu/random/TTL
    3.全空间
    4.设置过过期的key的集合中

# 7.如何进行缓存预热？
    1.提前把数据塞入redis(你知道哪些是热数据吗？肯定不知道，会造成上线很多数据没有缓存命中)
    2.开发逻辑上也要规避差集（你没缓存的），会造成击穿，穿透，雪崩
    3.一劳永逸，未来也不怕
    结合第4个问题

# 8.数据库与缓存不一致如何解决？
    1.我们可以使用分布式事务来解决（意义不大），读多写稀有情况
    2.redis是缓存，更倾向于稍微的有时差
    3.减少DB的操作
    4.落地还是cannal


# 9.简述一下主从不一致的问题？
    1.redis的确默认是弱一致性，异步的同步
    2.锁不能用主从（单实例/分片集群/readlock）==> redisson
    3.在配置中提供了必须有多少个client连接能同步，你可以配置同步因子，趋向于强一致性
    4.wait 


#  10.描述一下redis持久化方式
    1.RDB,AOF；主从同步也算持久化
    2.高版本：开启AOF，AOF是可以通过执行日志得到全部内存数据的方式,但是追求性能
    2.1 体积变大，重复无效指令  重写，后台用线程把内存的kv生成指令写在新的AOF
    2.2 4.x 新增更有性能模式：把重写方式换成直接RDB放到aof文件头部，比2.1的方法快
    ，再追加日志


# 11.redis持久化原理
    1.当前线程阻塞服务  不聊
    2.异步后台进程完成持久

# 12.redis实现分布式锁的指令  为什么h使用setnxx？  redis的事务中三条指令是什么。第三条指令到达执行失败了，怎么处理






