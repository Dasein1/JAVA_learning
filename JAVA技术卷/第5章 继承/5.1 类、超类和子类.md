https://blog.csdn.net/weixin_30369183/article/details/115807179
# 1.定义子类
下面是由继承Employee类来定义Manager类的格式，关键字extends表示继承。
```java
public class Manager extends Employee
{
添加方法和域
}
```
关键字extends表明正在构造的==新类==派生于一个==已存在的类==。
已存在的类：超类、基类和父类。
新类：子类、派生类和孩子类。

继承了域



# 2.覆盖方法
==签名必须相同，返回类型必须兼容==
有些超类的方法在子类需要更新，在子类中写一个同名的方法来覆盖超类中的方法。
子类中的方法无法访问超类的私有域，如果要访问就要借助公有的接口。（使用super关键字）
例子：
```java
public double getSalary()
{
    double baseSalary=super.getSalary();
    return baseSalary+bonus;
}
```
在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。


## 对于返回类型必须兼容：
==允许子类将覆盖方法的返回类型定义为原返回类型的子类型==
```java
public Employee getBuddy()  {...}
public Manager getBuddy()   {...}
```

## 子类方法不能低于超类方法的可见性。
如，超类方法是public，子类方法一定要声明为public，否则会编译报错。
```java
public class test {
    public static void main(String[] args){
        B b=new B();
        System.out.println("s");
    }
}
class A{
    public int name(){
        return 1;
    }
}
class B extends A{
    private int name(){
        return 1;
    }
}
```


# 3.子类构造器
通过super实现对超类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句。
如果子类的构造器没有显式地调用超类的构造器，则将==自动地调用==超类默认（没有参数) 的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有==显式地调用超类的其他构造器==，则 Java 编译器将报告错误。

# ==注释==：
关键字this的两个用途：
1.引用隐式参数
2.调用该类其他的构造器。

关键字super的两个用途：
1.调用超类的方法
2.调用超类的构造器

调用构造器的语句只能作为另一个构造器的第一条语句出现。


# 4.继承层次
继承层次：由一个公共超类派生出来的所有类的集合。
继承链：从某个特定的类型到其祖先的路径。

==注意==：JAVA不支持多继承。多继承功能如何实现？



# 5.多态
在Java中，对象变量是多态的，一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象。
例如：
```java
Manager boss=new Manager(...);
Employee[] staff = new Employee[3];
staff[0]=boss;  
```
变量staff[0]与boss引用同一个对象，但编译器将staff[0]看成Employee对象。
可以这样调用
```java
boss.setBonus(5000); //OK
```
但不能这样调用
```java
staff[0].setBonus(5000); //Error
```
这是因为staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。

==警告==:



# 6.理解方法调用
## 1）编译器查看对象的声明类型和方法名。
假设调用x.f(param)，且隐式参数x声明为C类的对象。编译器会一一列举所有==C类中名为f的方法==和==其超类中访问属性为public且名为f的方法==（超类的私有方法不可访问）

## 2）编译器查看调用方法时提供的参数类型。
重载解析：如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。
如果编译器没有找到与参数类型匹配的方法，或者发现经过==类型转换==后有多个方法与之匹配，就会报告一个错误。（编译器允许类型转换）


## 3）如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，这种调用方式成为静态绑定。
动态绑定：调用的方法依赖于隐式参数的实际类型（==这里的实际类型是就子类和超类而言，子类是实际类型，和引用变量的声明类型一致==），并且在运行时实现动态绑定。


# 7.阻止继承：final类和方法
final类：该类不能被继承
final方法：子类不能覆盖这个方法（final类中的所有方法自动地成为final方法）
final域：构造对象之后不允许改变它们的值

## 为什么要将方法或类声明为final？
1.final方法：Calendar类中的getTime和setTime方法都声明为final。这表明该类的设计者不允许子类处理这些问题。
2.final类：如String类是final类，不允许任何人定义String的子类。（如果有一个String的引用，它引用的一定是一个String对象，不可能是其他类的对象）


# 8.强制类型转换
## 将某个类的对象引用转换成另外一个类的对象引用
### 怎么转换？
```java
Manager boss = (Manager) staff[0];
```

### 为什么转换？
唯一原因：在暂时忽视对象的实际类型之后，使用对象的全部功能。
一般应用场景：
staff数组 是Employee对象的数组   其中有些项是经理，我们需要将数组中引用经理的元素复原成Manager类，以便能够访问新增加的所有变量。

==注意==:
1.只能在继承层次内进行类型转换。
2.在将超类转换成子类之前，应该使用instanceof进行检查。
