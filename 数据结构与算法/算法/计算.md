# 平均查找长度
查找成功ASL
对于查找一个存在于数据结构中的关键字来说，需要的期望查找长度
pi*长度之和
查找失败ASL
https://blog.csdn.net/weixin_43838785/article/details/103837042
https://blog.csdn.net/Ang_go/article/details/117302523#SnippetTab

哈希表
链地址法、线性探测

# 排序算法比较
## 冒泡算法
比较n趟，每一趟中，从左至右将数组的每个元素和其下一个元素进行比较并交换位置。
最好情况为：O(n) 所有元素已经排好序
最坏情况为：O(n^2) 所有元素为相反顺序
平均：O(n^2)
空间复杂度：O(1)
原地排序： 原地交换顺序
内存：不需要额外空间
稳定性：稳定，规定两个元素相等时不进行交换即可

## 选择排序
for i:n
    确定从arr[i]到数组末尾中最小的元素，放到arr[i]位置
最好情况：O(n^2)
最坏情况：O(n^2)
平均:O(n^2)       无论什么情况，确定从arr[i]到数组末尾中的最小元素都需要全部进行比较
空间复杂度：O(1)
原地排序
内存：不需要额外空间
稳定性：不稳定，比如arr[i]和arr[n-1]都是最小元素，那么会将arr[n-1]确定为最小元素，故不稳定

## 插入排序
arr[i]左边为已排序，arr[i]右边为未排序
for i:n
    for(i-1->0):
        将arr[i]插入已排序数组对应位置      
最好情况：O(n)    所有元素已经排好序
最坏情况：O(n^2)  所有元素为相反顺序
平均：O(n^2)
空间复杂度：O(1)
原地排序
内存：不需要额外空间
稳定性：稳定， 规定如果arr[i]大于或者等于被比较元素，就插入该元素后面

## 堆排序
用数组来表示堆（优先队列）arr[i]左边为已排序，arr[i]右边为未排序
for i:n
    将arr[i]加入已排序堆末尾并不断与父节点比较大小
最好情况：
### 堆的构造
将无序数组构造成一个堆
O(nlogn) 从左至右swim
O(n)  从右至左sink

### 堆重排序
1.直接下沉：
    移去堆顶元素后，将数组末尾元素放到堆顶，sink

2.先下沉后上浮：
    移去堆顶元素后，将空缺sink到堆底，然后用数组末尾元素填补空缺，最后将该元素swim（降低元素比较次数从2N到N）
https://blog.csdn.net/markjenny/article/details/46828029
最好情况：O(nlogn)
最坏情况：O(nlogn)
平均:O(nlogn)  无论什么情况，重排序阶段都要nlogn

## 从一个很大很大的数组里找前N个最大（小）数的思路
    1.堆排序：维护大小为n的堆
        

# 递归算法计算

# 保留n位小数，四舍五入或截取
BIGDECIMAL 
https://blog.csdn.net/qq_35868412/article/details/89029288
