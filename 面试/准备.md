# 1.自我介绍

# 2.笔试题目
## 第一题
10题 2分 10题 4分 5题8分
### 递归
1.记录做到该题时的得分，和错题数
2.终止条件：错题数大于3，得分大于目标， 得分等于目标返回并结果+1
  主体：该题做错，做下一题
        该题做对，做下一题

### 

## 第二题
替换子树
树的数组   路径   替换的子树数组
### 思路
构建                                         



# 3.Java基础、多线程、数据结构与算法
## 并查集
https://blog.csdn.net/weixin_38279101/article/details/112546053

## 



三次握手  
第一次握手：建立连接 客户端向服务器发送的报文当中的SYN位被设置为1，表示请求与服务器建立连接。
第二次握手：服务器收到SYN报文段 服务器收到客户端发来的连接请求报文后，紧接着向客户端发起连接建立请求并对客户端发来的连接请求进行响应，此时服务器向客户端发送的报文当中的SYN位和ACK位均被设置为1。
第三次握手：客户端收到服务器的 SYN+ACK 报文段 客户端收到服务器发来的报文后，得知服务器收到了自己发送的连接建立请求，并请求和自己建立连接，最后客户端再向服务器发来的报文进行响应。
四次挥手 

第一次挥手：客户端准备断开连接 客户端向服务器发送的报文当中的FIN位被设置为1，表示请求与服务器断开连接。
第二次挥手：服务器收到FIN报文段 服务器收到客户端发来的断开连接请求后对其进行响应，返回确认应答包（ACK报文段）。
第三次挥手：服务器发送FIN报文段 请求关闭连接  服务器收到客户端断开连接的请求，且已经没有数据需要发送给客户端的时候，服务器就会向客户端发起断开连接请求。
第四次挥手：客户端向服务器发送ACK报文段 客户端收到服务器发来的断开连接请求后对其进行响应，对服务器发送ACK报文段，服务器收到后直接关闭，客户端再等待2MSL后关闭。



类的线程安全表现为：
操作的原子性
内存的可见性
不做正确的同步，在多个线程之间共享状态的时候，就会出现线程不安全。
1、操作的原子性
原子性在之前的篇章都有讲过，就不细说了。主要就是表示一个操作是不可中断的，或者不可在分割的，要么全部执行成功要么全部执行失败。
2、内存的可见性
多个线程对同一个变量（称为：共享变量）进行操作，但是这多个线程有可能被分配到多个处理器中运行，那么编译器会对代码进行优化，当线程要处理该变量时，多个处理器会将变量从主存复制一份分别存储在自己的存储器中，等到进行完操作后，再赋值回主存。

1、HashMap
数据结构：数组 + 链表 + 红黑树
安全性：非线程安全，因为底层代码操作数组时未加锁。
应用场景：高并发情况下，put、remove 成员变量时可能产生线程安全问题，需加锁；
操作非成员标量时不会发生线程安全问题，可以不用加锁。
扩容：元素插入后判断数组长度是否超阈，默认阈值0.75，若超阈则进行扩容，扩容大小为原数组的2的幂次方，若原数组所在内存上没有连续的可用空间，则申请新的可用连续空间，将旧数组复制到新的地址，再将旧数组置为null，等待GC回收。
缩容：无动态缩容机制，需手动缩容。

2、concurrentHashMap
数据结构：分段数组 + 链表 + 红黑树
安全性：线程安全，因为底层代码在操作每一个segment时都会对segment加锁，保证线程安全。
应用场景：高并发情况下，线程安全，操作成员变量或局部变量都不需要单独加锁处理。
性能：读取数据时不加锁，高效，且因为map中的value值是添加volatile关键字修饰的，可保证读取到最新值，降低CPU负载。
写入数据时，会先通过hashcode算法算出要写入的segment（桶的位置），然后锁定当前segment，而不是锁定整个数组，所以读写效率比hashTable要高很多。

1、浅克隆:对当前对象进行克隆,并克隆该对象所包含的8种基本数据类型和String类型属性（拷贝一份该对象并重新分配内存，即产生了新的对象）；但如果被克隆的对象中包含除8中数据类型和String类型外的其他类型的属性,浅克隆并不会克隆这些属性（即不会为这些属性分配内存，而是引用原来对象中的属性）
2、深克隆:深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
————————————————
版权声明：本文为CSDN博主「_大杂烩」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_44351616/article/details/125146241

public static void main(String[] args) {
	int[] arr = new int[]{1, 8, 5, 7, 2, 3, 4, 9, 6, 10};
	quicksort(arr, 0, arr.length - 1);
}

public static void quicksort(int[] arr, int left, int right) {
	if (right >= left) {
		//保存基数
		int basic = arr[left];
		//定义左右指针
		int i = left;
		int j = right;
		while (i < j) {		//左指针小于右指针
			while (i < j && arr[j] > basic) {//操作右指针找到小于基数的下标
				j--;
			}
			if (i < j) {
				arr[i] = arr[j];	//将右指针对应小于基数的值放到左指针所指的位置
				i++;				//左指针自加
			}
			while (i < j && arr[i] < basic) {//相反，找到大于基数的下标
				i++;
			}
			if (i < j) {
				arr[j] = arr[i];	//大于基数的值赋给右指针所指的位置
				j--;				//右指针自减
			}
		}
		arr[i] = basic;				//将基数放入到指针重合处
		quicksort(arr, left, i - 1);	//重复调用，对左半部分数组进行排序
		quicksort(arr, i + 1, right);	//对右半部分数组进行排序
	}
}
