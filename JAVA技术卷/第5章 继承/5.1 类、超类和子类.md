https://blog.csdn.net/weixin_30369183/article/details/115807179
# 1.定义子类
下面是由继承Employee类来定义Manager类的格式，关键字extends表示继承。
```java
public class Manager extends Employee
{
添加方法和域
}
```
关键字extends表明正在构造的==新类==派生于一个==已存在的类==。
已存在的类：超类、基类和父类。
新类：子类、派生类和孩子类。

继承了域
## 继承的特性
1.子类拥有父类非 private 的属性、方法。
2.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
3.子类可以用自己的方式实现父类的方法。
4.Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。
5.提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。

## 子类对超类的私有域的继承
尽管每一个Manager对象都拥有一个名为salary的域，但在Manager类的getSalary方法中并不能够直接地访问salary域。只有Employee类的方法才能够访问私有部分。如果Manager类的方法一定要访问私有域，就必须借助于公有的接口，Employee类中的公有方法getSalary正是这样一个接口。
见覆盖方法中的例子。

# 2.覆盖方法
==签名必须相同，返回类型必须兼容==
有些超类的方法在子类需要更新，在子类中写一个同名的方法来覆盖超类中的方法。
子类中的方法无法访问超类的私有域，如果要访问就要借助公有的接口。（使用super关键字）

例子：
```java
public double getSalary()
{
    double baseSalary=super.getSalary();
    return baseSalary+bonus;
}
```
在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。


## 对于返回类型必须兼容：
==允许子类将覆盖方法的返回类型定义为原返回类型的子类型==
```java
public Employee getBuddy()  {...}
public Manager getBuddy()   {...}
```

## 子类方法不能低于超类方法的可见性。
如，超类方法是public，子类方法一定要声明为public，否则会编译报错。
```java
public class test {
    public static void main(String[] args){
        B b=new B();
        System.out.println("s");
    }
}
class A{
    public int name(){
        return 1;
    }
}
class B extends A{
    private int name(){
        return 1;
    }
}
```


# 3.子类构造器
通过super实现对超类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句。
如果子类的构造器没有显式地调用超类的构造器，则将==自动地调用==超类默认（没有参数) 的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有==显式地调用超类的其他构造器==，则 Java 编译器将报告错误。

# ==注释==：
关键字this的两个用途：
1.引用隐式参数
2.调用该类其他的构造器。

关键字super的两个用途：
1.调用超类的方法
2.调用超类的构造器

调用构造器的语句只能作为另一个构造器的第一条语句出现。


# 4.继承层次
继承层次：由一个公共超类派生出来的所有类的集合。
继承链：从某个特定的类型到其祖先的路径。

==注意==：JAVA不支持多继承。多继承功能如何实现？



# 5.多态
在Java中，对象变量是多态的，一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象。
例如：
```java
Manager boss=new Manager(...);
Employee[] staff = new Employee[3];
staff[0]=boss;  
```
变量staff[0]与boss引用同一个对象，但编译器将staff[0]看成Employee对象。
可以这样调用
```java
boss.setBonus(5000); //OK
```
但不能这样调用
```java
staff[0].setBonus(5000); //Error
```
这是因为staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。

==警告==:



# 6.理解方法调用
## 1）编译器查看对象的声明类型和方法名。
假设调用x.f(param)，且隐式参数x声明为C类的对象。编译器会一一列举所有==C类中名为f的方法==和==其超类中访问属性为public且名为f的方法==（超类的私有方法不可访问）

## 2）编译器查看调用方法时提供的参数类型。
重载解析：如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。
如果编译器没有找到与参数类型匹配的方法，或者发现经过==类型转换==后有多个方法与之匹配，就会报告一个错误。（编译器允许类型转换）


## 3）如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，这种调用方式成为静态绑定。
动态绑定：调用的方法依赖于隐式参数的实际类型（==这里的实际类型是就子类和超类而言，子类是实际类型，和引用变量的声明类型一致==），并且在运行时实现动态绑定。


# 7.阻止继承：final类和方法
final类：该类不能被继承
final方法：子类不能覆盖这个方法（final类中的所有方法自动地成为final方法）
final域：构造对象之后不允许改变它们的值

## 为什么要将方法或类声明为final？
1.final方法：Calendar类中的getTime和setTime方法都声明为final。这表明该类的设计者不允许子类处理这些问题。
2.final类：如String类是final类，不允许任何人定义String的子类。（如果有一个String的引用，它引用的一定是一个String对象，不可能是其他类的对象）


# 8.强制类型转换
## 将某个类的对象引用转换成另外一个类的对象引用
### 怎么转换？
```java
Manager boss = (Manager) staff[0];
```

### 为什么转换？
唯一原因：在暂时忽视对象的实际类型之后，使用对象的全部功能。
一般应用场景：
staff数组 是Employee对象的数组   其中有些项是经理，我们需要将数组中引用经理的元素复原成Manager类，以便能够访问新增加的所有变量。

==注意==:
1.只能在继承层次内进行类型转换。
2.在将超类转换成子类之前，应该使用instanceof进行检查。

# 9.抽象类（菜鸟教程）
https://www.runoob.com/java/java-abstraction.html
## 什么是抽象类？
如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。


## 怎么声明抽象方法？
```java
public abstract double computePay();
```
1.关键字abstract。
2.抽象方法只包含一个方法名，而没有方法体。


## 声明抽象方法后果？
1.如果一个类包含抽象方法，那么该类必须是抽象类。
2.任何子类必须重写父类的抽象方法，或者声明自身为抽象类。


## 抽象类总结规定
1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。


# 10.受保护访问
private   仅对本类可见
public  对所有类可见
protected   对于本包和其子类可见
默认，不需要修饰符  对本包可见

[protected关键字详解](https://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html)